# Chapter15. アーキテクチャ

ソフトウェアアーキテクトとは

ソフトウェアアーキテクトはプログラマである
ソフトウェアアーキテクトは最高のプログラマであり, 生産性を最大化する設計にチームを導く

アーキテクチャとは

それを構築くした人が与えたシステムの形状
形状を生み出すためにシステムをコンポーネントに分割し, うまく配置して相互通信できるようにする必要がある
アーキテクチャの形状の目的は, システムの開発, デプロイ, 運用, 保守を用意にすること > システムを適切に動作させること
アーキテクチャはシステムの動作に影響を与えるものではない
アーキテクチャの目的はシステムのライフサイクルをサポートすること


## 開発

開発が難しいソフトウェアはライフタイムが短く不健全
アーキテクチャによって開発しやすくするシステムにするべき

アーキテクチャの決定はチーム構成によって異なる

## デプロイ

システムが効果を生み出すためにはデプロイ可能な状態でないといけない
デプロイコストが高いとシステムの有用性は低下する
アーキテクチャの目的は単一のアクションで簡単にデプロイできるようにすること
開発初期にデプロイが考慮されることは少ない
初期からデプロイを考慮していれば対策をとることができる

## 運用

開発/デプロイ/保守にくらべアーキテクチャの影響は小さい
運用の課題はハードウェアの変更で解決できる
ハードウェアのコスト < ソフトウェア（人）のコスト
優れたアーキテクチャであれば, システムの運用方法がわかりやすくなり, 開発や保守に役立つ

## 保守

最もコストがかかる
永遠に続く修正の繰り返しによる人的リソースの消費
主なコストは洞窟探検とリスク
洞窟探検 = 既存のソフトウェアを理解してどう修正するか決める作業
リスク = 間違った修正をして意図しない欠陥を生むこと

よいアーキテクチャならコストは大幅に低下する
システムをコンポーネントに分離して, 安定したインタフェースを持つ独立したコンポーネントにする

## 選択肢を残しておく

振る舞いの価値 < 構造(アーキテクチャ)の価値
ソフトウェアの柔軟性はシステムの形状, コンポーネントの配置, 相互接続に大きく依存する
ソフトに保つためにはできるだけ長い期間, 多くの選択肢を残しておくこと

残すべき選択肢 = 重要でない詳細

ソフトウェアの要素
* 方針 = ビジネスのルールや手順 = システムの価値
* 詳細 = IOデバイス, DB, Web, サーバ, フレームワークなど = 方針に影響しない

アーキテクトの目的は, 方針とは無関係に詳細を決めながら, 方針を最も重要な用途と認識するシステムの形状を作ること
これにより, 詳細の決定を延期や留保することができる
詳細の決定を延期することで, 適切に作るための情報が多く手に入る, 実験する機会も増える

すでに決定していたら? 優秀なアーキテクト「まだ決まってない」

## 決定遅延の例

* デバイス非依存
* ダイレクトメール
* 物理アドレス

# Chapter16. 独立性

優れたアーキテクチャがサポートすべきこと

* ユースケース
* システムの運用
* システムの開発
* システムのデプロイ

## ユースケース

アーキテクチャはシステムの意図をサポートしなければならない
アーキテクチャはシステムの振る舞いに影響を与えない

アーキテクチャレベルでシステムの意図がわかるように, 振る舞いを明らかにすること

= 振る舞いがシステムのトップレベル要素に合われれる(クラス, 関数, モジュールなど)


21章「叫ぶアーキテクチャ」でさらに明確にする
一戸建ての家をみて, 学校や病院, 図書館とは思わない. 家族が住む戸建てと明確にわかる
システムの上位レベルのパッケージやソースをみて何のソフトウェアかわかる?


## 運用

アーキテクチャはシステムの運用において, 本質的な役割を果たす
求められるユースケースに対して, スループットや応答時間など求められる性能をサポートしなければならない
そのための決定は選択肢として残しておく

モノリシックなシステムだと対応は難しい
適切なコンポーネントに分割しておけば複数プロセス/スレッド/マイクロサービス化への対応は可能

## 開発

アーキテクチャは開発環境のサポートにおいて重要な役割を果たす

コンウェイの法則
システムを設計する組織は, 組織のコミュニケーション構造をコピーした構造設計を生み出す

チームや利害関係の多い組織 => システムもお互いへの干渉が強くなる

独立して動けるチーム => システムも独立して開発できるようになる

## デプロイ

目指すは即時デプロイ
優れたアーキテクチャなら構築後すぐにデプロイできる
そのためには適切にコンポーネントに分割するｋとお

## 選択肢を残しておく

優れたアーキテクチャなら, すべての懸念を解決するコンポーネント構造のバランスをうまくとるこができる
言うのは簡単だがやるのは難しい

ユースケース, 運用上の制約, チーム構成, デプロイ要件が未確定, 決まっても時間の経過によって変わっていく


それでも, 問題のバランスをうまく取ることができるアーキテクチャの原則はある
この原則によって, システムを独立したコンポーネントに分割し, できるだけ長時間, 多くの選択肢を残すことができる

## レイヤーの切り離し

すべてのユースケースをサポートするシステムの構造が必要だが, すべてのユースケースを把握することはできない
しかしシステムの意図はわかっている

アーキテクトはSRPとCCPを使用して, システムの意図を考慮しながら, 異なる理由で変更されるものを分離し, 同じ理由で変更されるものをまとめることができる

異なる理由で変更されるもの
* UI
* ビジネスルール
    * アプリケーションと密接なもの
        * 入力フィールドの検証など
    * ドメインと密接なもの
        * 口座の利益計算, 在庫計算など
* DB


=> 水平レイヤーで分離

## ユースケースの切り離し

* 注文入力システムに注文を追加する
* 注文を削除する

異なる頻度と理由で変更される

ユースケースはシステムの水平レイヤーを薄く垂直にスライスしたもの
UI/アプリケーション/ビジネスルール/DB

注文入力システムに注文を追加するUIと注文を削除するUIを分離する

## 切り離し方式

運用の視点から切り離しの意味を考える

ユースケースを分離しておけば, 高いスループットのものと低いスループットのものがある
UIとDBがビジネスルールから分離されていれば, 異なるサーバで実行することができる
ユースケースの切り離しは, 運用の役に立つ

サービス指向アーキテクチャ/マイクロアーキテクチャという

切り離し方式も選択肢の一つである

## 独立した開発が可能

コンポーネントが明確に切り離されていれば, チーム間の干渉も緩和される
UIチームがビジネスルールチームに影響を与えることはない（逆はある）
注文追加のユースケースのチームが注文削除のユースケースのチームの邪魔はしない

## 独立デプロイ可能性

レイヤーやユースケースが切り離されていれば, デプロイも柔軟になる
稼働中のシステムにたいして, 特定のレイヤーやユースケースをホットスワップすることもできる

## 重複

重複は悪

重複には種類がある
* あるインスタンスに変更があれば, それらのコピーも同じ変更をする必要がある(本物の重複)
* 重複していたコードが異なる進化を遂げて, まったく違うものになる場合もある(偽物の重複, 偶然の重複)

画面構成やアルゴリズム, DBが似ているというだけで重複を排除してはいけない
本物の重複かどうか見分けること

## 切り離し方式(再び)

切り離す方法

* ソースコードレベル

あるモジュールへの変更が, 他のモジュールの変更や再コンパイルにつながらないようにする (Ruby Gems)
コンポーネント間の通信は関数呼び出し

* バイナリコードレベル

あるモジュールへの変更が, 他のモジュールの再ビルドやデプロイにつながらないようにする (Jar, DDL, 共有ライブラリ)
コンポーネント間の通信は関数呼び出しもしくはプロセス間通信, ソケット, 共有メモリなど

* サービスレベル

コンポーネント間の通信はネットワークパケット (マイクロサービス)

プロジェクト初期の段階で判断するのは難しい
プロジェクトのライフサイクルによって最適な方式もかわる

作者おすすめの方法

サービスレベルの分離ができそうなところまでコンポーネントを分離しておく
分離はするが, 実際はソースコードレベルまでにしておく
開発/デプロイ/運用の問題が多くなればデプロイやサービスレベルに変更する

優れたアーキテクチャがあれば、システムはモノリシックとして生まれ、単一ファイルでデ
プロイされ、独立してデプロイ可能な単位になるまで成長し、最後はサービスやマイクロサー
ビスまでたどり着くことが可能になるだろう。その後、物事が変わったときには、これまでの
流れを逆転させ、モノリシックまで戻せるようになっておくべきである。

## まとめ

システムの切 り離し方式は時間とともに変化する
優秀なアーキテクトであれば、そうした変化を予見して、適切に進めることができる

# Chapter17. バウンダリー・境界線を引く

ソフトウェアアーキテクチャとは境界線を引く技芸(バウンダリー)である

ソフトウェアの要素を分離し, お互いがわからないように制限すること

必要な人材を最小限におさえるというアーキテクチャの目的を妨げるものはなにか?

結合, 特に早すぎる決定との結合

早すぎる決定 = システムのビジネス要件と関係ない決定

* フレームワーク
* DB
* Webサーバ
* ユーティリティライブラリ
* DI

## 悲しい結合の物語

夢広がりんぐなアーキテクチャを早く導入しすぎて失敗した話

省略

## NetNesse

DBの決定を遅らせることで成功した自画自賛の話

省略

## あなたの境界線は何か? いつ境界線を引くのか?

「重要なもの」と「重要でないもの」の間

* ビジネスルールとUI
* ビジネスルールとDB
* UIとDB

データベースはビジネスルールにとって重要ではない

ビジネスルールが知る必要があるのは, データの永続化の機能があるということだけで, どう実装されているかは重要ではない

Pic 17-1

DatabaseはBisinessRolesを知っている, とあるが..

1. BusinessRuleはDatabaseInterfaceを使っている => BusinessRuleがないとコンパイルできない => DatabasseInterfaceはBisinessコンポーネントにあるべき
3. DatabaseAccessはDatabaseを使っている => Databaseがないとコンパイルできない => Database/DatabaseAccessはDBコンポーネントにあるべき
2. DatabaseAccessはDatbaseInterfaceを継承している => DatabaseInterfaceがないとコンパイルできない => でもBisinessとは直接関係ないので依存とする

## 入力と出力

IOは無関係の原則

UIはビジネスルールに依存するが, ビジネスルールはUIに依存しない
重要なのはビジネスルールである

## プラグインアーキテクチャ

他のコンポーネントを追加するパターン

UIやDBはプラグインとして置き換え可能

## プラグインの戦い

ReSharper vs Visual Studio

RsSharperがVisual Studioに依存しているため, Visual StudioテームはReShaperを無効化できる
逆はできない

境界線は変更の軸があるところに引く
境界線を挟んだコンポーネントはそれぞれの変更頻度や理由がちがってくる
UIとビジネスルールは異なる時間や頻度で変更される（同じタイミングのときもあるが）

## まとめ

境界線を引くにはまずコンポーネントに分割する

その中にコアのビジネスルールのコンポーネントになる

コアのビジネスに直接関係しないコンポーネント（UIやDB）はプラグインにしておく

これはDIPとSAPを適用したものになっている (詳細=実装が抽象に依存している)


